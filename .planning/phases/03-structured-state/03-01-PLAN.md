---
phase: 03-structured-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [SKILL.md]
autonomous: true
requirements: [TS-6, D-5, D-8]

must_haves:
  truths:
    - "manifest.json exists in $TMPDIR before the tmux session is created (pid=0 placeholder)"
    - "Every manifest write (initial, PID update, completion) goes through .tmp + mv atomic pattern"
    - "After task completion, manifest.json contains finished_at, exit_code (number), status (completed/failed), and output_tail (last 100 lines)"
    - "Brain can read a single JSON file for complete task state instead of parsing multiple ad-hoc files"
  artifacts:
    - path: "SKILL.md"
      provides: "6-step launch sequence with manifest creation, PID update, and completion update"
      contains: "manifest.json"
  key_links:
    - from: "SKILL.md Step 3 (initial manifest)"
      to: "SKILL.md Step 6 wrapper (PID update)"
      via: "jq --argjson pid updates manifest.json created in Step 3"
      pattern: "jq.*manifest\\.json"
    - from: "SKILL.md Step 6 wrapper (completion update)"
      to: "SKILL.md Step 6 wrapper (touch done)"
      via: "manifest completion update ordered BEFORE touch done"
      pattern: "manifest\\.json.*touch.*done"
---

<objective>
Add JSON task manifest to SKILL.md launch sequence -- initial creation before tmux session, PID update after $! capture, completion update with output_tail before done-file touch.

Purpose: Give the Brain a single machine-readable JSON file to query for any task's status, output, and result without parsing multiple ad-hoc files. This replaces reading separate pid/exit_code/output.log files individually.

Output: Updated SKILL.md with 6-step launch sequence, manifest creation step, expanded wrapper with jq manifest updates, updated checklist, and updated task directory schema status note.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-structured-state/03-RESEARCH.md
@.planning/phases/02-detection-infrastructure/02-01-SUMMARY.md
@SKILL.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add manifest.json creation step and update wrapper with jq manifest updates</name>
  <files>SKILL.md</files>
  <action>
Update SKILL.md to add manifest.json support. All changes are in a single file. The research at 03-RESEARCH.md has the exact code patterns -- follow them precisely.

**1. Insert new Step 3 between current Step 2 and Step 3 (renumber current Steps 3-5 to 4-6):**

Add a new Step 3 that creates the initial manifest.json using `jq -n`. The step uses the atomic write-to-tmp + mv pattern. All eight fields: task_name, model, project_dir, session_name, pid (0 placeholder), tmpdir, started_at (ISO 8601 UTC), status ("running"). Use `--arg pid "0"` with `($pid | tonumber)` for numeric PID, and `--argjson` is NOT needed here since `--arg` + `tonumber` handles the conversion.

```bash
# Step 3: Create initial manifest
jq -n \
  --arg task_name "<task-name>" \
  --arg model "<model-name>" \
  --arg project_dir "<project-dir>" \
  --arg session_name "claude-<task-name>" \
  --arg pid "0" \
  --arg tmpdir "$TMPDIR" \
  --arg started_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
  --arg status "running" \
  '{task_name: $task_name, model: $model, project_dir: $project_dir, session_name: $session_name, pid: ($pid | tonumber), tmpdir: $tmpdir, started_at: $started_at, status: $status}' \
  > "$TMPDIR/manifest.json.tmp" && mv "$TMPDIR/manifest.json.tmp" "$TMPDIR/manifest.json"
```

**2. Expand the Step 6 send-keys wrapper** to include PID manifest update (after PID write) and completion manifest update (after exit_code write, before touch done):

PID update (insert between `echo "$CLAUDE_PID" > "$TASK_TMPDIR/pid"` and `wait $CLAUDE_PID`):
```
jq --argjson pid "$CLAUDE_PID" '.pid = $pid' "$TASK_TMPDIR/manifest.json" > "$TASK_TMPDIR/manifest.json.tmp" && mv "$TASK_TMPDIR/manifest.json.tmp" "$TASK_TMPDIR/manifest.json"
```

Completion update (insert after exit_code mv, before touch done):
```
if [ "$ECODE" -eq 0 ]; then STATUS=completed; else STATUS=failed; fi
jq --arg finished_at "$(date -u +"%Y-%m-%dT%H:%M:%SZ")" --argjson exit_code "$ECODE" --arg status "$STATUS" --arg output_tail "$(tail -n 100 "$TASK_TMPDIR/output.log" 2>/dev/null || echo "")" '. + {finished_at: $finished_at, exit_code: $exit_code, status: $status, output_tail: $output_tail}' "$TASK_TMPDIR/manifest.json" > "$TASK_TMPDIR/manifest.json.tmp" && mv "$TASK_TMPDIR/manifest.json.tmp" "$TASK_TMPDIR/manifest.json"
```

CRITICAL quoting for send-keys: The entire wrapper is single-quoted. Inside the single-quoted string:
- Shell variables ($CLAUDE_PID, $TASK_TMPDIR, $ECODE, $STATUS) are evaluated by the pane shell -- use them as-is
- jq variable references ($pid, $finished_at, $exit_code, $status, $output_tail) must use `\$varname` so the pane shell passes literal `$` to jq. In the send-keys string: `.pid = \$pid`, `\$finished_at`, `\$exit_code`, `\$status`, `\$output_tail`

The wrapper now captures ECODE=$? (already done for exit_code) and uses it for both exit_code file and manifest status field.

**3. Update the Completion Notification variant** to include the same manifest updates. The ordering becomes: exit_code write -> manifest completion update -> openclaw event -> touch done.

**4. Update the Step 5 explanation paragraph** (renumbered to Step 6) to describe the new manifest update steps in the wrapper.

**5. Update the Task Directory Schema** status note to reflect that Phase 3 implements manifest.json. Change the comment for manifest.json from "Created: Phase 3" to note it is now active. Update the status paragraph at the bottom to note Phase 3 creates manifest.json.

**6. Update the Checklist** section to add manifest.json creation as a step (between "Write prompt" and "Create tmux session").

**7. Add a "Prerequisites" note** about jq being required. In the Prerequisites section, add jq to the list: `- **jq** -- JSON manifest creation and updates (available at /usr/bin/jq on macOS)`

DO NOT change monitor.sh -- that is Phase 4's job.
DO NOT change any detection logic or existing wrapper behavior.
DO NOT change pipe-pane setup, ANSI stripping, or cleanup sections.
  </action>
  <verify>
Verify these patterns exist in the updated SKILL.md:

1. `grep -c 'manifest.json' SKILL.md` returns 5+ (multiple references)
2. `grep 'Step 3.*manifest' SKILL.md` finds the new step
3. `grep 'Step 6.*wrapper' SKILL.md` finds the renumbered wrapper step
4. `grep 'jq -n' SKILL.md` finds the initial manifest creation
5. `grep 'jq.*argjson.*pid' SKILL.md` finds the PID update
6. `grep 'output_tail' SKILL.md` finds the completion update
7. `grep 'manifest.json.tmp' SKILL.md` finds atomic write pattern (at least 3 occurrences: initial, PID update, completion)
8. `grep 'jq' SKILL.md` in Prerequisites section confirms jq is listed
9. Step numbering is sequential 1-6 with no gaps
10. The send-keys wrapper uses `\$` for jq variables inside the single-quoted string
  </verify>
  <done>
SKILL.md has a 6-step launch sequence where Step 3 creates manifest.json with all eight fields (task_name, model, project_dir, session_name, pid=0, tmpdir, started_at, status=running) using atomic tmp+mv. The send-keys wrapper updates PID via jq after $! capture, and adds finished_at, exit_code, status, output_tail via jq merge before touch done. All three manifest writes use the atomic pattern. The Completion Notification variant includes manifest updates. Task Directory Schema, Checklist, and Prerequisites reflect the manifest.json addition.
  </done>
</task>

</tasks>

<verification>
Phase 3 verification criteria (from ROADMAP Success Criteria):

1. **SC1 -- manifest.json exists at task start**: SKILL.md Step 3 creates manifest.json before `tmux new-session` (Step 4). Contains all eight fields: task_name, model, project_dir, session_name, pid (0), tmpdir, started_at, status.

2. **SC2 -- atomic writes**: All three manifest write points (initial creation in Step 3, PID update in wrapper, completion update in wrapper) use the `> manifest.json.tmp && mv manifest.json.tmp manifest.json` pattern. The `&&` ensures mv only runs if jq succeeds.

3. **SC3 -- completion fields**: The wrapper completion update adds finished_at (ISO 8601 UTC), exit_code (number via --argjson), status (completed/failed), and output_tail (last 100 lines via tail -n 100). This update is ordered BEFORE `touch done`.
</verification>

<success_criteria>
- SKILL.md contains a 6-step launch sequence (up from 5)
- Step 3 creates manifest.json with jq -n and atomic write pattern
- The send-keys wrapper includes PID manifest update and completion manifest update
- All manifest writes use .tmp + mv atomic pattern
- Completion update includes finished_at, exit_code (numeric), status, output_tail
- Manifest completion update is ordered before touch done
- Completion Notification variant includes manifest updates
- Task Directory Schema status note updated for Phase 3
- Checklist includes manifest.json creation step
- Prerequisites lists jq
- No changes to monitor.sh
</success_criteria>

<output>
After completion, create `.planning/phases/03-structured-state/03-01-SUMMARY.md`
</output>
