---
phase: 02-detection-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: [scripts/monitor.sh]
autonomous: true
requirements: [TS-1, TS-2]

must_haves:
  truths:
    - "Monitor checks done-file FIRST in every loop iteration before any other detection"
    - "Monitor reads PID from $TASK_TMPDIR/pid and uses kill -0 for liveness check"
    - "Monitor does not grep scrollback for __TASK_DONE__ or shell prompt patterns"
    - "Monitor resumes via claude -c when PID is dead and no done-file exists"
    - "Monitor accepts TASK_TMPDIR as second argument for filesystem signal paths"
  artifacts:
    - path: "scripts/monitor.sh"
      provides: "Filesystem-signal-based health monitor with done-file and PID detection"
      contains: "kill -0"
  key_links:
    - from: "scripts/monitor.sh (done-file check)"
      to: "$TASK_TMPDIR/done"
      via: "[ -f done ] existence check as highest priority"
      pattern: '\\[ -f.*done \\]'
    - from: "scripts/monitor.sh (PID check)"
      to: "$TASK_TMPDIR/pid"
      via: "cat pid file then kill -0"
      pattern: "kill -0.*PID"
    - from: "scripts/monitor.sh (crash recovery)"
      to: "tmux send-keys claude -c"
      via: "Resume on PID death without done-file"
      pattern: "send-keys.*claude -c"
---

<objective>
Rewrite monitor.sh to replace regex-based crash detection (shell prompt matching, __TASK_DONE__ grep, exit hint regex) with deterministic filesystem signal checks: done-file for completion and kill -0 PID for liveness.

Purpose: The current monitor parses tmux scrollback with fragile regex patterns that produce false positives. This rewrite makes detection deterministic -- a file exists or it doesn't, a process is alive or it isn't. No heuristics.

Output: Updated scripts/monitor.sh that uses done-file check (priority 1) and PID liveness (priority 2) instead of scrollback regex parsing.
</objective>

<execution_context>
@/Users/matt/.claude/get-shit-done/workflows/execute-plan.md
@/Users/matt/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-detection-infrastructure/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@scripts/monitor.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace monitor.sh regex detection with done-file + PID liveness checks</name>
  <files>scripts/monitor.sh</files>
  <action>
Rewrite `scripts/monitor.sh` to use filesystem-based detection instead of scrollback regex parsing. Preserve the existing structure (shebang, strict mode, session validation, exponential backoff, 5-hour deadline) but replace the detection logic entirely.

**Change the script signature**: Add TASK_TMPDIR as a required second argument:
```bash
SESSION="${1:?Usage: monitor.sh <tmux-session> <task-tmpdir>}"
TASK_TMPDIR="${2:?Usage: monitor.sh <tmux-session> <task-tmpdir>}"
```
Add validation that TASK_TMPDIR is a directory: `[ -d "$TASK_TMPDIR" ] || { echo "TASK_TMPDIR not a directory: $TASK_TMPDIR" >&2; exit 1; }`

**Update the file header comment**: Replace the description to reflect the new detection method:
```
# Monitor a Claude Code session running in tmux.
# Detects completion via done-file and crashes via PID liveness (kill -0).
# Auto-resumes crashed sessions using `claude -c`.
#
# Usage:
#   ./scripts/monitor.sh <tmux-session> <task-tmpdir>
#
#   tmux-session  Name of the tmux session (e.g. claude-refactor-auth)
#   task-tmpdir   Path to the task's secure temp directory ($TMPDIR from launch)
```

**Replace the entire detection block inside the while loop** (everything inside the `if tmux has-session` block). Remove:
- The `tmux capture-pane` call (no longer reading scrollback)
- The `RECENT` variable and `tail -n 40`
- The `__TASK_DONE__` grep check
- The `PROMPT_BACK` and `EXIT_HINT` variables
- The shell prompt regex (`grep -Eq '^[^[:space:]]*[$%#>] $'`)
- The exit indicator regex (`grep -Eiq '(exit code [0-9]|exited with|exit status [1-9])'`)

Replace with the three-priority detection flow from the research:

```bash
# Read PID from file (may not exist yet if agent is still starting)
if [ -f "$TASK_TMPDIR/pid" ]; then
  PID="$(cat "$TASK_TMPDIR/pid")"
else
  # PID file not yet written -- agent still starting
  sleep "$INTERVAL"
  continue
fi

# Priority 1: Done-file = task completed
if [ -f "$TASK_TMPDIR/done" ]; then
  EXIT_CODE="$(cat "$TASK_TMPDIR/exit_code" 2>/dev/null || echo "unknown")"
  echo "Task completed with exit code: $EXIT_CODE"
  break
fi

# Priority 2: PID dead = crash (no done-file means abnormal exit)
if ! kill -0 "$PID" 2>/dev/null; then
  RETRY_COUNT=$(( RETRY_COUNT + 1 ))
  echo "Crash detected (PID $PID gone). Resuming Claude Code (retry #$RETRY_COUNT)"
  tmux send-keys -t "$SESSION" 'claude -c' Enter
  # Grace period: after resume, new process needs time to start.
  # PID file is stale (contains dead PID). Phase 4 will address PID re-capture.
  # For now, sleep longer than the normal interval to avoid rapid resume loops.
  sleep 10
  continue
fi

# Priority 3: Process alive, no completion -- healthy
RETRY_COUNT=0
```

**Keep the existing session-gone handling**: The `else` branch for `tmux has-session` failure stays the same ("tmux session no longer exists. Stopping monitor.").

**Keep the existing backoff logic**: `INTERVAL=$(( 180 * (2 ** RETRY_COUNT) ))` and the deadline cap. But move the `sleep "$INTERVAL"` to the END of the loop body (after the detection block), not inside branches. The `continue` statements in the PID-not-found and crash-detected branches skip to the next iteration with their own sleep.

**Keep the existing deadline enforcement**: The `NOW_TS` / `DEADLINE_TS` check at the top of the loop is unchanged.

**Preserve conventions** (per CONVENTIONS.md):
- UPPERCASE for constants: SESSION, TASK_TMPDIR, PID, EXIT_CODE, RETRY_COUNT, INTERVAL, DEADLINE_TS
- 2-space indentation
- `printf '%s\n'` for safe output (though echo is acceptable for simple strings per existing style)
- Error messages to stderr with `>&2`
- `set -uo pipefail` at top

**Do NOT add**: Heartbeat/staleness detection (that is Phase 4), manifest updates (Phase 3), or configurable intervals (Phase 4). Keep the hardcoded 180s base interval and 5h deadline for now.
  </action>
  <verify>
Verify no scrollback parsing remains: `grep -c "capture-pane" scripts/monitor.sh` should return 0.
Verify no __TASK_DONE__: `grep -c "__TASK_DONE__" scripts/monitor.sh` should return 0.
Verify no prompt regex: `grep -c "PROMPT_BACK" scripts/monitor.sh` should return 0.
Verify no exit hint regex: `grep -c "EXIT_HINT" scripts/monitor.sh` should return 0.
Verify done-file check: `grep -c "done" scripts/monitor.sh` should return at least 2 (file check + echo).
Verify PID liveness: `grep -c "kill -0" scripts/monitor.sh` should return at least 1.
Verify TASK_TMPDIR argument: `grep -c "TASK_TMPDIR" scripts/monitor.sh` should return at least 3.
Run `bash -n scripts/monitor.sh` to confirm no syntax errors.
  </verify>
  <done>
monitor.sh accepts two arguments (session name, task tmpdir), checks done-file as highest priority, uses kill -0 for PID liveness, resumes via claude -c on crash detection, and contains zero scrollback regex parsing. The script passes bash -n syntax check.
  </done>
</task>

</tasks>

<verification>
- `bash -n scripts/monitor.sh` exits 0 (no syntax errors)
- `grep -c "capture-pane" scripts/monitor.sh` returns 0 (no scrollback parsing)
- `grep -c "__TASK_DONE__" scripts/monitor.sh` returns 0 (no marker grep)
- `grep -c "PROMPT_BACK\|EXIT_HINT" scripts/monitor.sh` returns 0 (no regex heuristics)
- `grep "kill -0" scripts/monitor.sh` shows PID liveness check
- `grep '\[ -f.*done \]' scripts/monitor.sh` shows done-file check
- `grep "TASK_TMPDIR" scripts/monitor.sh` shows task tmpdir usage throughout
</verification>

<success_criteria>
monitor.sh detects task completion via done-file existence and crashes via PID liveness -- zero regex heuristics remain. The monitor works with the filesystem signals produced by the SKILL.md wrapper pattern (pid, done, exit_code files).
</success_criteria>

<output>
After completion, create `.planning/phases/02-detection-infrastructure/02-02-SUMMARY.md`
</output>
